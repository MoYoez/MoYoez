import camelcaseKeys from 'camelcase-keys';
import { isPlainObject } from '../utils';
import { resolveFullPath } from '../utils/path';
import { allContollerNames } from '../controllers';
import { attachRequestMethod } from './attach-request';
import { RequestError } from './error';
const methodPrefix = '_$';
class HTTPClient {
    constructor(_endpoint, _adaptor, options = {}) {
        this._endpoint = _endpoint;
        this._adaptor = _adaptor;
        this.options = options;
        this._endpoint = _endpoint
            .replace(/\/*$/, '')
            .replace('localhost', '127.0.0.1');
        this._proxy = this.buildRoute(this)();
        this.initGetClient();
        attachRequestMethod(this);
    }
    initGetClient() {
        for (const name of allContollerNames) {
            Object.defineProperty(this, name, {
                get() {
                    const client = Reflect.get(this, `${methodPrefix}${name}`);
                    if (!client) {
                        throw new ReferenceError(`${name.charAt(0).toUpperCase() + name.slice(1)} Client not inject yet, please inject with client.injectClients(...)`);
                    }
                    return client;
                },
                configurable: false,
                enumerable: false,
            });
        }
    }
    injectControllers(Controller, ...rest) {
        Controller = Array.isArray(Controller) ? Controller : [Controller, ...rest];
        for (const Client of Controller) {
            const cl = new Client(this);
            if (Array.isArray(cl.name)) {
                for (const name of cl.name) {
                    attach.call(this, name, cl);
                }
            }
            else {
                attach.call(this, cl.name, cl);
            }
        }
        function attach(name, cl) {
            Object.defineProperty(this, `${methodPrefix}${name.toLowerCase()}`, {
                get() {
                    return cl;
                },
                enumerable: false,
                configurable: false,
            });
        }
    }
    get endpoint() {
        return this._endpoint;
    }
    get instance() {
        return this._adaptor;
    }
    request(options) {
        return this[`$$${String(options.method || 'get').toLowerCase()}`](options.url, options);
    }
    get proxy() {
        return this._proxy;
    }
    buildRoute(manager) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const noop = () => { };
        const methods = ['get', 'post', 'delete', 'patch', 'put'];
        const reflectors = [
            'toString',
            'valueOf',
            'inspect',
            'constructor',
            Symbol.toPrimitive,
        ];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        return () => {
            const route = [''];
            const handler = {
                get(target, name) {
                    if (reflectors.includes(name))
                        return (withBase) => {
                            if (withBase) {
                                const path = resolveFullPath(that.endpoint, route.join('/'));
                                route.length = 0;
                                return path;
                            }
                            else {
                                const path = route.join('/');
                                route.length = 0;
                                return path.startsWith('/') ? path : `/${path}`;
                            }
                        };
                    if (methods.includes(name)) {
                        return async (options) => {
                            const url = resolveFullPath(that.endpoint, route.join('/'));
                            route.length = 0;
                            let res;
                            try {
                                res = await manager.request({
                                    method: name,
                                    ...options,
                                    url,
                                });
                            }
                            catch (e) {
                                let message = e.message;
                                let code = e.code ||
                                    e.status ||
                                    e.statusCode ||
                                    e.response?.status ||
                                    e.response?.statusCode ||
                                    e.response?.code ||
                                    500;
                                if (that.options.getCodeMessageFromException) {
                                    const errorInfo = that.options.getCodeMessageFromException(e);
                                    message = errorInfo.message || message;
                                    code = errorInfo.code || code;
                                }
                                throw new RequestError(message, code, url, e);
                            }
                            const data = res.data;
                            if (!data) {
                                return null;
                            }
                            const transform = Array.isArray(data) || isPlainObject(data)
                                ? camelcaseKeys(data, { deep: true })
                                : data;
                            if (transform && typeof transform === 'object') {
                                Object.defineProperty(transform, '$raw', {
                                    get() {
                                        return res;
                                    },
                                    enumerable: false,
                                    configurable: false,
                                });
                                // attach request config onto response
                                Object.defineProperty(transform, '$request', {
                                    get() {
                                        return {
                                            url,
                                            method: name,
                                            options,
                                        };
                                    },
                                    enumerable: false,
                                });
                            }
                            return transform;
                        };
                    }
                    route.push(name);
                    return new Proxy(noop, handler);
                },
                // @ts-ignore
                apply(target, _, args) {
                    route.push(...args.filter((x) => x !== null));
                    return new Proxy(noop, handler);
                },
            };
            return new Proxy(noop, handler);
        };
    }
}
export function createClient(adapter) {
    return (endpoint, options) => {
        const client = new HTTPClient(endpoint, adapter, options);
        const { controllers } = options || {};
        if (controllers) {
            client.injectControllers(controllers);
        }
        return client;
    };
}
//# sourceMappingURL=client.js.map