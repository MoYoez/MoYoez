'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var camelcaseKeys$1 = require('camelcase-keys');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var camelcaseKeys__default = /*#__PURE__*/_interopDefaultLegacy(camelcaseKeys$1);

const isPlainObject = (obj) => isObject(obj) &&
    Object.prototype.toString.call(obj) === '[object Object]' &&
    Object.getPrototypeOf(obj) === Object.prototype;
const sortOrderToNumber = (order) => {
    return ({
        asc: 1,
        desc: -1,
    }[order] || 1);
};
const isObject = (obj) => obj && typeof obj === 'object';
const destructureData = (payload) => {
    if (typeof payload !== 'object') {
        return payload;
    }
    if (payload === null) {
        return payload;
    }
    const data = payload.data;
    const dataIsPlainObject = isPlainObject(data);
    if (dataIsPlainObject && Object.keys(payload).length === 1) {
        const d = Object.assign({}, data);
        // attach raw onto new data
        attachRawFromOneToAnthor(payload, d);
        return d;
    }
    return payload;
};
const attachRawFromOneToAnthor = (from, to) => {
    if (!from || !isObject(to)) {
        return;
    }
    from.$raw &&
        Object.defineProperty(to, '$raw', {
            value: { ...from.$raw },
            enumerable: false,
        });
    from.$request &&
        Object.defineProperty(to, '$request', {
            value: { ...from.$request },
            enumerable: false,
        });
};

// @ts-nocheck
// @copy: https://github.com/sindresorhus/auto-bind/blob/main/index.js
// Gets all non-builtin properties up the prototype chain.
const getAllProperties = (object) => {
    const properties = new Set();
    do {
        for (const key of Reflect.ownKeys(object)) {
            properties.add([object, key]);
        }
    } while ((object = Reflect.getPrototypeOf(object)) &&
        object !== Object.prototype);
    return properties;
};
function autoBind(self, { include, exclude } = {}) {
    const filter = (key) => {
        const match = (pattern) => typeof pattern === 'string' ? key === pattern : pattern.test(key);
        if (include) {
            return include.some(match);
        }
        if (exclude) {
            return !exclude.some(match);
        }
        return true;
    };
    for (const [object, key] of getAllProperties(self.constructor.prototype)) {
        if (key === 'constructor' || !filter(key)) {
            continue;
        }
        const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
        if (descriptor && typeof descriptor.value === 'function') {
            self[key] = self[key].bind(self);
        }
    }
    return self;
}

class AggregateController {
    constructor(client) {
        this.client = client;
        this.base = 'aggregate';
        this.name = 'aggregate';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 获取聚合数据
     */
    getAggregateData() {
        return this.proxy.get();
    }
    /**
     * 获取最新发布的内容
     */
    getTop(size = 5) {
        return this.proxy.top.get({ params: { size } });
    }
    getTimeline(options) {
        const { sort, type, year } = options || {};
        return this.proxy.timeline.get({
            params: {
                sort: sort && sortOrderToNumber(sort),
                type,
                year,
            },
        });
    }
    /**
     * 获取聚合数据统计
     */
    getStat() {
        return this.proxy.stat.get();
    }
}

class RequestError extends Error {
    constructor(message, status, path, raw) {
        super(message);
        this.status = status;
        this.path = path;
        this.raw = raw;
    }
}

exports.CategoryType = void 0;
(function (CategoryType) {
    CategoryType[CategoryType["Category"] = 0] = "Category";
    CategoryType[CategoryType["Tag"] = 1] = "Tag";
})(exports.CategoryType || (exports.CategoryType = {}));

class CategoryController {
    constructor(client) {
        this.client = client;
        this.name = 'category';
        this.base = 'categories';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    getAllCategories() {
        return this.proxy.get({
            params: {
                type: exports.CategoryType.Category,
            },
        });
    }
    getAllTags() {
        return this.proxy.get({
            params: {
                type: exports.CategoryType.Tag,
            },
        });
    }
    async getCategoryDetail(ids) {
        if (typeof ids === 'string') {
            const data = await this.proxy.get({
                params: {
                    ids,
                },
            });
            const result = Object.values(data.entries)[0];
            attachRawFromOneToAnthor(data, result);
            return result;
        }
        else if (Array.isArray(ids)) {
            const data = await this.proxy.get({
                params: {
                    ids: ids.join(','),
                },
            });
            const entries = data?.entries;
            if (!entries) {
                throw new RequestError('data structure error', 500, data.$request.path, data);
            }
            const map = new Map(Object.entries(entries).map(([id, value]) => [id.toLowerCase(), value]));
            attachRawFromOneToAnthor(data, map);
            return map;
        }
    }
    async getCategoryByIdOrSlug(idOrSlug) {
        const res = await this.proxy(idOrSlug).get();
        return destructureData(res);
    }
    async getTagByName(name) {
        const res = await this.proxy(name).get({
            params: {
                tag: 1,
            },
        });
        return res;
    }
}

class CommentController {
    constructor(client) {
        this.client = client;
        this.base = 'comments';
        this.name = 'comment';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 根据 comment id 获取评论, 包括子评论
     */
    getById(id) {
        return this.proxy(id).get();
    }
    /**
     * 获取文章的评论列表
     * @param refId 文章 Id
     */
    getByRefId(refId, pagination = {}) {
        const { page, size } = pagination;
        return this.proxy
            .ref(refId)
            .get({
            params: { page: page || 1, size: size || 10 },
        });
    }
    /**
     * 评论
     */
    comment(refId, data) {
        return this.proxy(refId).post({
            data,
        });
    }
    /**
     * 回复评论
     */
    reply(commentId, data) {
        return this.proxy.reply(commentId).post({
            data,
        });
    }
}

class BaseCrudController {
    constructor(client) {
        this.client = client;
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    getById(id) {
        return this.proxy(id).get();
    }
    getAll() {
        return this.proxy.all.get();
    }
    /**
     * 带分页的查询
     * @param page
     * @param perPage
     */
    getAllPaginated(page, perPage, sortOption) {
        return this.proxy.get({
            params: { page, size: perPage, ...sortOption },
        });
    }
}

class LinkController extends BaseCrudController {
    constructor(client) {
        super(client);
        this.client = client;
        this.name = ['link', 'friend'];
        this.base = 'links';
        autoBind(this);
    }
    // 是否可以申请友链
    async canApplyLink() {
        const { can } = await this.proxy.audit.get();
        return can;
    }
    // 申请友链
    async applyLink(data) {
        return await this.proxy.audit.post({ data });
    }
}

class NoteController {
    constructor(client) {
        this.client = client;
        this.base = 'notes';
        this.name = 'note';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 最新日记
     */
    getLatest() {
        return this.proxy.latest.get();
    }
    getNoteById(...rest) {
        const [id, password = undefined, singleResult = false] = rest;
        if (typeof id === 'number') {
            return this.proxy.nid(id.toString()).get({
                params: { password, single: singleResult ? '1' : undefined },
            });
        }
        else {
            return this.proxy(id).get();
        }
    }
    /**
     * 日记列表分页
     */
    getList(page = 1, perPage = 10, options = {}) {
        const { select, sortBy, sortOrder, year } = options;
        return this.proxy.get({
            params: {
                page,
                size: perPage,
                select: select?.join(' '),
                sortBy,
                sortOrder,
                year,
            },
        });
    }
    /**
     * 获取当前日记的上下各 n / 2 篇日记
     */
    getMiddleList(id, size = 5) {
        return this.proxy.list(id).get({
            params: { size },
        });
    }
    /**
     * 喜欢这篇日记
     */
    likeIt(id) {
        return this.proxy.like(id).get();
    }
    /**
     * 获取专栏内的所有日记
     */
    getNoteByTopicId(topicId, page = 1, size = 10, sortOptions = {}) {
        return this.proxy.topics(topicId).get({
            params: { page, size, ...sortOptions },
        });
    }
}

class PageController {
    constructor(client) {
        this.client = client;
        this.base = 'pages';
        this.name = 'page';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 页面列表
     */
    getList(page = 1, perPage = 10, options = {}) {
        const { select, sortBy, sortOrder } = options;
        return this.proxy.get({
            params: {
                page,
                size: perPage,
                select: select?.join(' '),
                sortBy,
                sortOrder,
            },
        });
    }
    /**
     * 页面详情
     */
    getById(id) {
        return this.proxy(id).get();
    }
    /**
     * 根据路径获取页面
     * @param slug 路径
     * @returns
     */
    getBySlug(slug) {
        return this.proxy.slug(slug).get({});
    }
}

class PostController {
    constructor(client) {
        this.client = client;
        this.base = 'posts';
        this.name = 'post';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 获取文章列表分页
     * @param page
     * @param perPage
     * @returns
     */
    getList(page = 1, perPage = 10, options = {}) {
        const { select, sortBy, sortOrder, year } = options;
        return this.proxy.get({
            params: {
                page,
                size: perPage,
                select: select?.join(' '),
                sortBy,
                sortOrder,
                year,
            },
        });
    }
    getPost(idOrCategoryName, slug) {
        if (arguments.length == 1) {
            return this.proxy(idOrCategoryName).get();
        }
        else {
            return this.proxy(idOrCategoryName)(slug).get();
        }
    }
    /**
     * 获取最新的文章
     */
    getLatest() {
        return this.proxy.latest.get();
    }
    /**
     * 点赞
     */
    thumbsUp(id) {
        return this.proxy('_thumbs-up').get({ params: { id } });
    }
}

class ProjectController extends BaseCrudController {
    constructor(client) {
        super(client);
        this.client = client;
        this.base = 'projects';
        this.name = 'project';
        autoBind(this);
    }
}

class RecentlyController {
    constructor(client) {
        this.client = client;
        this.base = 'recently';
        this.name = ['recently', 'shorthand'];
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 获取最新一条
     */
    getLatestOne() {
        return this.proxy.latest.get();
    }
    getAll() {
        return this.proxy.all.get();
    }
    getList(before, after, size) {
        return this.proxy.get({
            params: {
                before,
                after,
                size,
            },
        });
    }
}

class SayController extends BaseCrudController {
    constructor(client) {
        super(client);
        this.client = client;
        this.base = 'says';
        this.name = 'say';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    /**
     * 获取随机一条
     */
    getRandom() {
        return this.proxy.random.get();
    }
}

class SearchController {
    constructor(client) {
        this.client = client;
        this.base = 'search';
        this.name = 'search';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    search(type, keyword, options = {}) {
        return this.proxy(type).get({
            params: { keyword, ...options },
        });
    }
    /**
     * 从 algolya 搜索
     * https://www.algolia.com/doc/api-reference/api-methods/search/
     * @param keyword
     * @param options
     * @returns
     */
    searchByAlgolia(keyword, options) {
        return this.proxy('algolia').get({ params: { keyword, ...options } });
    }
}

class ServerlessController {
    constructor(client) {
        this.client = client;
        this.base = 'serverless';
        this.name = 'serverless';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    getByReferenceAndName(reference, name) {
        return this.proxy(reference)(name).get();
    }
}

class SnippetController {
    constructor(client) {
        this.client = client;
        this.base = 'snippets';
        this.name = 'snippet';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    // getById(id: string) {
    //   return this.proxy(id).get<Omit<SnippetModel, 'data'>>()
    // }
    getByReferenceAndName(reference, name) {
        return this.proxy(reference)(name).get();
    }
}

class TopicController extends BaseCrudController {
    constructor(client) {
        super(client);
        this.client = client;
        this.base = 'topics';
        this.name = 'topic';
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    getTopicBySlug(slug) {
        return this.proxy.slug(slug).get();
    }
}

class UserController {
    constructor(client) {
        this.client = client;
        this.base = 'master';
        this.name = ['user', 'master'];
        autoBind(this);
    }
    get proxy() {
        return this.client.proxy(this.base);
    }
    getMasterInfo() {
        return this.proxy.get();
    }
    login(username, password) {
        return this.proxy.login.post({
            data: {
                username,
                password,
            },
        });
    }
    checkTokenValid(token) {
        return this.proxy.check_logged.get({
            params: {
                token: `bearer ${token.replace(/^Bearer\s/i, '')}`,
            },
        });
    }
}

const allControllers = [
    AggregateController,
    CategoryController,
    CommentController,
    LinkController,
    NoteController,
    PageController,
    PostController,
    ProjectController,
    RecentlyController,
    TopicController,
    SayController,
    SearchController,
    SnippetController,
    ServerlessController,
    UserController,
];
const allContollerNames = [
    'aggregate',
    'category',
    'comment',
    'link',
    'note',
    'page',
    'post',
    'project',
    'topic',
    'recently',
    'say',
    'search',
    'snippet',
    'serverless',
    'user',
    // alias,
    'friend',
    'master',
    'shorthand',
];

const resolveFullPath = (endpoint, path) => {
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }
    return `${endpoint}${path}`;
};

function attachRequestMethod(target) {
    Object.defineProperty(target, '$$get', {
        value(url, options) {
            // HINT: method get only accept search params;
            const { params = {} } = options;
            const qs = handleSearchParams(params);
            return target.instance.get(`${url}${qs ? `${`?${qs}`}` : ''}`, options);
        },
    });
    ['put', 'post', 'patch', 'delete'].forEach((method) => {
        Object.defineProperty(target, `$$${method}`, {
            value(path, options) {
                return target.instance[method](path, options);
            },
        });
    });
}
// FIXME: only support string value
function handleSearchParams(obj) {
    if (!obj && typeof obj !== 'object') {
        throw new TypeError('params must be object.');
    }
    if (obj instanceof URLSearchParams) {
        return obj.toString();
    }
    const search = new URLSearchParams();
    Object.entries(obj).forEach(([k, v]) => {
        if (typeof v === 'undefined' ||
            Object.prototype.toString.call(v) === '[object Null]') {
            return;
        }
        search.set(k, v);
    });
    return search.toString();
}

const methodPrefix = '_$';
class HTTPClient {
    constructor(_endpoint, _adaptor, options = {}) {
        this._endpoint = _endpoint;
        this._adaptor = _adaptor;
        this.options = options;
        this._endpoint = _endpoint
            .replace(/\/*$/, '')
            .replace('localhost', '127.0.0.1');
        this._proxy = this.buildRoute(this)();
        this.initGetClient();
        attachRequestMethod(this);
    }
    initGetClient() {
        for (const name of allContollerNames) {
            Object.defineProperty(this, name, {
                get() {
                    const client = Reflect.get(this, `${methodPrefix}${name}`);
                    if (!client) {
                        throw new ReferenceError(`${name.charAt(0).toUpperCase() + name.slice(1)} Client not inject yet, please inject with client.injectClients(...)`);
                    }
                    return client;
                },
                configurable: false,
                enumerable: false,
            });
        }
    }
    injectControllers(Controller, ...rest) {
        Controller = Array.isArray(Controller) ? Controller : [Controller, ...rest];
        for (const Client of Controller) {
            const cl = new Client(this);
            if (Array.isArray(cl.name)) {
                for (const name of cl.name) {
                    attach.call(this, name, cl);
                }
            }
            else {
                attach.call(this, cl.name, cl);
            }
        }
        function attach(name, cl) {
            Object.defineProperty(this, `${methodPrefix}${name.toLowerCase()}`, {
                get() {
                    return cl;
                },
                enumerable: false,
                configurable: false,
            });
        }
    }
    get endpoint() {
        return this._endpoint;
    }
    get instance() {
        return this._adaptor;
    }
    request(options) {
        return this[`$$${String(options.method || 'get').toLowerCase()}`](options.url, options);
    }
    get proxy() {
        return this._proxy;
    }
    buildRoute(manager) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const noop = () => { };
        const methods = ['get', 'post', 'delete', 'patch', 'put'];
        const reflectors = [
            'toString',
            'valueOf',
            'inspect',
            'constructor',
            Symbol.toPrimitive,
        ];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        return () => {
            const route = [''];
            const handler = {
                get(target, name) {
                    if (reflectors.includes(name))
                        return (withBase) => {
                            if (withBase) {
                                const path = resolveFullPath(that.endpoint, route.join('/'));
                                route.length = 0;
                                return path;
                            }
                            else {
                                const path = route.join('/');
                                route.length = 0;
                                return path.startsWith('/') ? path : `/${path}`;
                            }
                        };
                    if (methods.includes(name)) {
                        return async (options) => {
                            const url = resolveFullPath(that.endpoint, route.join('/'));
                            route.length = 0;
                            let res;
                            try {
                                res = await manager.request({
                                    method: name,
                                    ...options,
                                    url,
                                });
                            }
                            catch (e) {
                                let message = e.message;
                                let code = e.code ||
                                    e.status ||
                                    e.statusCode ||
                                    e.response?.status ||
                                    e.response?.statusCode ||
                                    e.response?.code ||
                                    500;
                                if (that.options.getCodeMessageFromException) {
                                    const errorInfo = that.options.getCodeMessageFromException(e);
                                    message = errorInfo.message || message;
                                    code = errorInfo.code || code;
                                }
                                throw new RequestError(message, code, url, e);
                            }
                            const data = res.data;
                            if (!data) {
                                return null;
                            }
                            const transform = Array.isArray(data) || isPlainObject(data)
                                ? camelcaseKeys__default["default"](data, { deep: true })
                                : data;
                            if (transform && typeof transform === 'object') {
                                Object.defineProperty(transform, '$raw', {
                                    get() {
                                        return res;
                                    },
                                    enumerable: false,
                                    configurable: false,
                                });
                                // attach request config onto response
                                Object.defineProperty(transform, '$request', {
                                    get() {
                                        return {
                                            url,
                                            method: name,
                                            options,
                                        };
                                    },
                                    enumerable: false,
                                });
                            }
                            return transform;
                        };
                    }
                    route.push(name);
                    return new Proxy(noop, handler);
                },
                // @ts-ignore
                apply(target, _, args) {
                    route.push(...args.filter((x) => x !== null));
                    return new Proxy(noop, handler);
                },
            };
            return new Proxy(noop, handler);
        };
    }
}
function createClient(adapter) {
    return (endpoint, options) => {
        const client = new HTTPClient(endpoint, adapter, options);
        const { controllers } = options || {};
        if (controllers) {
            client.injectControllers(controllers);
        }
        return client;
    };
}

exports.TimelineType = void 0;
(function (TimelineType) {
    TimelineType[TimelineType["Post"] = 0] = "Post";
    TimelineType[TimelineType["Note"] = 1] = "Note";
})(exports.TimelineType || (exports.TimelineType = {}));

exports.RefType = void 0;
(function (RefType) {
    RefType["Page"] = "Page";
    RefType["Post"] = "Post";
    RefType["Note"] = "Note";
})(exports.RefType || (exports.RefType = {}));
exports.CommentState = void 0;
(function (CommentState) {
    CommentState[CommentState["Unread"] = 0] = "Unread";
    CommentState[CommentState["Read"] = 1] = "Read";
    CommentState[CommentState["Junk"] = 2] = "Junk";
})(exports.CommentState || (exports.CommentState = {}));

exports.LinkType = void 0;
(function (LinkType) {
    LinkType[LinkType["Friend"] = 0] = "Friend";
    LinkType[LinkType["Collection"] = 1] = "Collection";
})(exports.LinkType || (exports.LinkType = {}));
exports.LinkState = void 0;
(function (LinkState) {
    LinkState[LinkState["Pass"] = 0] = "Pass";
    LinkState[LinkState["Audit"] = 1] = "Audit";
    LinkState[LinkState["Outdate"] = 2] = "Outdate";
    LinkState[LinkState["Banned"] = 3] = "Banned";
})(exports.LinkState || (exports.LinkState = {}));

exports.EnumPageType = void 0;
(function (EnumPageType) {
    EnumPageType["md"] = "md";
    EnumPageType["html"] = "html";
    EnumPageType["frame"] = "frame";
})(exports.EnumPageType || (exports.EnumPageType = {}));

exports.SnippetType = void 0;
(function (SnippetType) {
    SnippetType["JSON"] = "json";
    SnippetType["Function"] = "function";
    SnippetType["Text"] = "text";
    SnippetType["YAML"] = "yaml";
})(exports.SnippetType || (exports.SnippetType = {}));

// export helper lib
const camelcaseKeysDeep = (obj) => {
    return camelcaseKeys(obj, { deep: true });
};
const camelcaseKeys = camelcaseKeys__default["default"];

exports.AggregateController = AggregateController;
exports.CategoryController = CategoryController;
exports.CommentController = CommentController;
exports.LinkController = LinkController;
exports.NoteController = NoteController;
exports.PageController = PageController;
exports.PostController = PostController;
exports.ProjectController = ProjectController;
exports.RecentlyController = RecentlyController;
exports.RequestError = RequestError;
exports.SayController = SayController;
exports.SearchController = SearchController;
exports.ServerlessController = ServerlessController;
exports.SnippetController = SnippetController;
exports.TopicController = TopicController;
exports.UserController = UserController;
exports.allContollerNames = allContollerNames;
exports.allControllers = allControllers;
exports.camelcaseKeys = camelcaseKeys;
exports.camelcaseKeysDeep = camelcaseKeysDeep;
exports.createClient = createClient;
//# sourceMappingURL=index.cjs.js.map
